import type { QueryOptions } from "../evaluator/index.js";
import { JSONPathQuery } from "./query-instance.js";
export declare class QueryBuilder<T = unknown> {
    private data;
    private path?;
    private options;
    private filterFn?;
    private mapFn?;
    private sortFn?;
    private takeCount?;
    private skipCount?;
    private dedup;
    private uniqueKeyFn?;
    private flattenDepth?;
    constructor(data: unknown);
    query(path: string): this;
    withOptions(options: QueryOptions): this;
    resultType(type: QueryOptions["resultType"]): this;
    wrapped(enabled?: boolean): this;
    cached(enabled?: boolean): this;
    withParent(parent: unknown, parentProperty?: string | number): this;
    filter(fn: (value: unknown) => boolean): this;
    map(fn: (value: unknown) => unknown): this;
    sort(fn: (a: unknown, b: unknown) => number): this;
    take(count: number): this;
    skip(count: number): this;
    deduplicate(): this;
    unique(keyFn?: (value: T) => unknown): this;
    flatten(depth?: number): this;
    autostart(value: boolean): this;
    execute(): Promise<T[]>;
    executeSync(): T[];
    build(): JSONPathQuery;
    private postProcess;
    exists(): Promise<boolean>;
    every(predicate: (value: T) => boolean): Promise<boolean>;
    some(predicate: (value: T) => boolean): Promise<boolean>;
    find(predicate: (value: T) => boolean): Promise<T | undefined>;
    reduce<R>(reducer: (acc: R, value: T) => R, initial: R): Promise<R>;
    groupBy<K extends string | number | symbol>(keyFn: (value: T) => K): Promise<Record<string, T[]>>;
    partition(predicate: (value: T) => boolean): Promise<[T[], T[]]>;
    stats(): Promise<{
        count: number;
        min?: number;
        max?: number;
        sum: number;
        avg?: number;
    }>;
    first(): Promise<T | undefined>;
    last(): Promise<T | undefined>;
    count(): Promise<number>;
}
export declare function createQueryBuilder<T = unknown>(data: unknown): QueryBuilder<T>;
